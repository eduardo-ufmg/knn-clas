// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: classifier.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_classifier_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_classifier_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_classifier_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_classifier_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_classifier_2eproto;
namespace classifierpb {
class Dataset;
struct DatasetDefaultTypeInternal;
extern DatasetDefaultTypeInternal _Dataset_default_instance_;
class DatasetEntry;
struct DatasetEntryDefaultTypeInternal;
extern DatasetEntryDefaultTypeInternal _DatasetEntry_default_instance_;
class PredictedSampleEntry;
struct PredictedSampleEntryDefaultTypeInternal;
extern PredictedSampleEntryDefaultTypeInternal _PredictedSampleEntry_default_instance_;
class PredictedSamples;
struct PredictedSamplesDefaultTypeInternal;
extern PredictedSamplesDefaultTypeInternal _PredictedSamples_default_instance_;
class SupportSampleEntry;
struct SupportSampleEntryDefaultTypeInternal;
extern SupportSampleEntryDefaultTypeInternal _SupportSampleEntry_default_instance_;
class SupportSamples;
struct SupportSamplesDefaultTypeInternal;
extern SupportSamplesDefaultTypeInternal _SupportSamples_default_instance_;
class Target;
struct TargetDefaultTypeInternal;
extern TargetDefaultTypeInternal _Target_default_instance_;
class TestSampleEntry;
struct TestSampleEntryDefaultTypeInternal;
extern TestSampleEntryDefaultTypeInternal _TestSampleEntry_default_instance_;
class TestSamples;
struct TestSamplesDefaultTypeInternal;
extern TestSamplesDefaultTypeInternal _TestSamples_default_instance_;
}  // namespace classifierpb
PROTOBUF_NAMESPACE_OPEN
template<> ::classifierpb::Dataset* Arena::CreateMaybeMessage<::classifierpb::Dataset>(Arena*);
template<> ::classifierpb::DatasetEntry* Arena::CreateMaybeMessage<::classifierpb::DatasetEntry>(Arena*);
template<> ::classifierpb::PredictedSampleEntry* Arena::CreateMaybeMessage<::classifierpb::PredictedSampleEntry>(Arena*);
template<> ::classifierpb::PredictedSamples* Arena::CreateMaybeMessage<::classifierpb::PredictedSamples>(Arena*);
template<> ::classifierpb::SupportSampleEntry* Arena::CreateMaybeMessage<::classifierpb::SupportSampleEntry>(Arena*);
template<> ::classifierpb::SupportSamples* Arena::CreateMaybeMessage<::classifierpb::SupportSamples>(Arena*);
template<> ::classifierpb::Target* Arena::CreateMaybeMessage<::classifierpb::Target>(Arena*);
template<> ::classifierpb::TestSampleEntry* Arena::CreateMaybeMessage<::classifierpb::TestSampleEntry>(Arena*);
template<> ::classifierpb::TestSamples* Arena::CreateMaybeMessage<::classifierpb::TestSamples>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace classifierpb {

// ===================================================================

class Target final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:classifierpb.Target) */ {
 public:
  inline Target() : Target(nullptr) {}
  ~Target() override;
  explicit PROTOBUF_CONSTEXPR Target(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Target(const Target& from);
  Target(Target&& from) noexcept
    : Target() {
    *this = ::std::move(from);
  }

  inline Target& operator=(const Target& from) {
    CopyFrom(from);
    return *this;
  }
  inline Target& operator=(Target&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Target& default_instance() {
    return *internal_default_instance();
  }
  enum TargetCase {
    kTargetInt = 1,
    kTargetStr = 2,
    TARGET_NOT_SET = 0,
  };

  static inline const Target* internal_default_instance() {
    return reinterpret_cast<const Target*>(
               &_Target_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Target& a, Target& b) {
    a.Swap(&b);
  }
  inline void Swap(Target* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Target* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Target* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Target>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Target& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Target& from) {
    Target::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Target* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "classifierpb.Target";
  }
  protected:
  explicit Target(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetIntFieldNumber = 1,
    kTargetStrFieldNumber = 2,
  };
  // int32 target_int = 1;
  bool has_target_int() const;
  private:
  bool _internal_has_target_int() const;
  public:
  void clear_target_int();
  int32_t target_int() const;
  void set_target_int(int32_t value);
  private:
  int32_t _internal_target_int() const;
  void _internal_set_target_int(int32_t value);
  public:

  // string target_str = 2;
  bool has_target_str() const;
  private:
  bool _internal_has_target_str() const;
  public:
  void clear_target_str();
  const std::string& target_str() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_target_str(ArgT0&& arg0, ArgT... args);
  std::string* mutable_target_str();
  PROTOBUF_NODISCARD std::string* release_target_str();
  void set_allocated_target_str(std::string* target_str);
  private:
  const std::string& _internal_target_str() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target_str(const std::string& value);
  std::string* _internal_mutable_target_str();
  public:

  void clear_target();
  TargetCase target_case() const;
  // @@protoc_insertion_point(class_scope:classifierpb.Target)
 private:
  class _Internal;
  void set_has_target_int();
  void set_has_target_str();

  inline bool has_target() const;
  inline void clear_has_target();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union TargetUnion {
      constexpr TargetUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int32_t target_int_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr target_str_;
    } target_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_classifier_2eproto;
};
// -------------------------------------------------------------------

class DatasetEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:classifierpb.DatasetEntry) */ {
 public:
  inline DatasetEntry() : DatasetEntry(nullptr) {}
  ~DatasetEntry() override;
  explicit PROTOBUF_CONSTEXPR DatasetEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DatasetEntry(const DatasetEntry& from);
  DatasetEntry(DatasetEntry&& from) noexcept
    : DatasetEntry() {
    *this = ::std::move(from);
  }

  inline DatasetEntry& operator=(const DatasetEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline DatasetEntry& operator=(DatasetEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DatasetEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const DatasetEntry* internal_default_instance() {
    return reinterpret_cast<const DatasetEntry*>(
               &_DatasetEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DatasetEntry& a, DatasetEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(DatasetEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DatasetEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DatasetEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DatasetEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DatasetEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DatasetEntry& from) {
    DatasetEntry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DatasetEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "classifierpb.DatasetEntry";
  }
  protected:
  explicit DatasetEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFeaturesFieldNumber = 1,
    kTargetFieldNumber = 2,
  };
  // repeated float features = 1;
  int features_size() const;
  private:
  int _internal_features_size() const;
  public:
  void clear_features();
  private:
  float _internal_features(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_features() const;
  void _internal_add_features(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_features();
  public:
  float features(int index) const;
  void set_features(int index, float value);
  void add_features(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      features() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_features();

  // .classifierpb.Target target = 2;
  bool has_target() const;
  private:
  bool _internal_has_target() const;
  public:
  void clear_target();
  const ::classifierpb::Target& target() const;
  PROTOBUF_NODISCARD ::classifierpb::Target* release_target();
  ::classifierpb::Target* mutable_target();
  void set_allocated_target(::classifierpb::Target* target);
  private:
  const ::classifierpb::Target& _internal_target() const;
  ::classifierpb::Target* _internal_mutable_target();
  public:
  void unsafe_arena_set_allocated_target(
      ::classifierpb::Target* target);
  ::classifierpb::Target* unsafe_arena_release_target();

  // @@protoc_insertion_point(class_scope:classifierpb.DatasetEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > features_;
    ::classifierpb::Target* target_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_classifier_2eproto;
};
// -------------------------------------------------------------------

class Dataset final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:classifierpb.Dataset) */ {
 public:
  inline Dataset() : Dataset(nullptr) {}
  ~Dataset() override;
  explicit PROTOBUF_CONSTEXPR Dataset(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Dataset(const Dataset& from);
  Dataset(Dataset&& from) noexcept
    : Dataset() {
    *this = ::std::move(from);
  }

  inline Dataset& operator=(const Dataset& from) {
    CopyFrom(from);
    return *this;
  }
  inline Dataset& operator=(Dataset&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Dataset& default_instance() {
    return *internal_default_instance();
  }
  static inline const Dataset* internal_default_instance() {
    return reinterpret_cast<const Dataset*>(
               &_Dataset_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Dataset& a, Dataset& b) {
    a.Swap(&b);
  }
  inline void Swap(Dataset* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Dataset* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Dataset* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Dataset>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Dataset& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Dataset& from) {
    Dataset::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Dataset* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "classifierpb.Dataset";
  }
  protected:
  explicit Dataset(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 1,
  };
  // repeated .classifierpb.DatasetEntry entries = 1;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::classifierpb::DatasetEntry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::classifierpb::DatasetEntry >*
      mutable_entries();
  private:
  const ::classifierpb::DatasetEntry& _internal_entries(int index) const;
  ::classifierpb::DatasetEntry* _internal_add_entries();
  public:
  const ::classifierpb::DatasetEntry& entries(int index) const;
  ::classifierpb::DatasetEntry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::classifierpb::DatasetEntry >&
      entries() const;

  // @@protoc_insertion_point(class_scope:classifierpb.Dataset)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::classifierpb::DatasetEntry > entries_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_classifier_2eproto;
};
// -------------------------------------------------------------------

class SupportSampleEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:classifierpb.SupportSampleEntry) */ {
 public:
  inline SupportSampleEntry() : SupportSampleEntry(nullptr) {}
  ~SupportSampleEntry() override;
  explicit PROTOBUF_CONSTEXPR SupportSampleEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SupportSampleEntry(const SupportSampleEntry& from);
  SupportSampleEntry(SupportSampleEntry&& from) noexcept
    : SupportSampleEntry() {
    *this = ::std::move(from);
  }

  inline SupportSampleEntry& operator=(const SupportSampleEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline SupportSampleEntry& operator=(SupportSampleEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SupportSampleEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const SupportSampleEntry* internal_default_instance() {
    return reinterpret_cast<const SupportSampleEntry*>(
               &_SupportSampleEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SupportSampleEntry& a, SupportSampleEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(SupportSampleEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SupportSampleEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SupportSampleEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SupportSampleEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SupportSampleEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SupportSampleEntry& from) {
    SupportSampleEntry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SupportSampleEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "classifierpb.SupportSampleEntry";
  }
  protected:
  explicit SupportSampleEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFeaturesFieldNumber = 2,
    kTargetFieldNumber = 3,
    kSampleIdFieldNumber = 1,
  };
  // repeated float features = 2;
  int features_size() const;
  private:
  int _internal_features_size() const;
  public:
  void clear_features();
  private:
  float _internal_features(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_features() const;
  void _internal_add_features(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_features();
  public:
  float features(int index) const;
  void set_features(int index, float value);
  void add_features(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      features() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_features();

  // .classifierpb.Target target = 3;
  bool has_target() const;
  private:
  bool _internal_has_target() const;
  public:
  void clear_target();
  const ::classifierpb::Target& target() const;
  PROTOBUF_NODISCARD ::classifierpb::Target* release_target();
  ::classifierpb::Target* mutable_target();
  void set_allocated_target(::classifierpb::Target* target);
  private:
  const ::classifierpb::Target& _internal_target() const;
  ::classifierpb::Target* _internal_mutable_target();
  public:
  void unsafe_arena_set_allocated_target(
      ::classifierpb::Target* target);
  ::classifierpb::Target* unsafe_arena_release_target();

  // int32 sample_id = 1;
  void clear_sample_id();
  int32_t sample_id() const;
  void set_sample_id(int32_t value);
  private:
  int32_t _internal_sample_id() const;
  void _internal_set_sample_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:classifierpb.SupportSampleEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > features_;
    ::classifierpb::Target* target_;
    int32_t sample_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_classifier_2eproto;
};
// -------------------------------------------------------------------

class SupportSamples final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:classifierpb.SupportSamples) */ {
 public:
  inline SupportSamples() : SupportSamples(nullptr) {}
  ~SupportSamples() override;
  explicit PROTOBUF_CONSTEXPR SupportSamples(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SupportSamples(const SupportSamples& from);
  SupportSamples(SupportSamples&& from) noexcept
    : SupportSamples() {
    *this = ::std::move(from);
  }

  inline SupportSamples& operator=(const SupportSamples& from) {
    CopyFrom(from);
    return *this;
  }
  inline SupportSamples& operator=(SupportSamples&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SupportSamples& default_instance() {
    return *internal_default_instance();
  }
  static inline const SupportSamples* internal_default_instance() {
    return reinterpret_cast<const SupportSamples*>(
               &_SupportSamples_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SupportSamples& a, SupportSamples& b) {
    a.Swap(&b);
  }
  inline void Swap(SupportSamples* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SupportSamples* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SupportSamples* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SupportSamples>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SupportSamples& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SupportSamples& from) {
    SupportSamples::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SupportSamples* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "classifierpb.SupportSamples";
  }
  protected:
  explicit SupportSamples(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 1,
  };
  // repeated .classifierpb.SupportSampleEntry entries = 1;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::classifierpb::SupportSampleEntry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::classifierpb::SupportSampleEntry >*
      mutable_entries();
  private:
  const ::classifierpb::SupportSampleEntry& _internal_entries(int index) const;
  ::classifierpb::SupportSampleEntry* _internal_add_entries();
  public:
  const ::classifierpb::SupportSampleEntry& entries(int index) const;
  ::classifierpb::SupportSampleEntry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::classifierpb::SupportSampleEntry >&
      entries() const;

  // @@protoc_insertion_point(class_scope:classifierpb.SupportSamples)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::classifierpb::SupportSampleEntry > entries_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_classifier_2eproto;
};
// -------------------------------------------------------------------

class TestSampleEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:classifierpb.TestSampleEntry) */ {
 public:
  inline TestSampleEntry() : TestSampleEntry(nullptr) {}
  ~TestSampleEntry() override;
  explicit PROTOBUF_CONSTEXPR TestSampleEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestSampleEntry(const TestSampleEntry& from);
  TestSampleEntry(TestSampleEntry&& from) noexcept
    : TestSampleEntry() {
    *this = ::std::move(from);
  }

  inline TestSampleEntry& operator=(const TestSampleEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestSampleEntry& operator=(TestSampleEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestSampleEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestSampleEntry* internal_default_instance() {
    return reinterpret_cast<const TestSampleEntry*>(
               &_TestSampleEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TestSampleEntry& a, TestSampleEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(TestSampleEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestSampleEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestSampleEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestSampleEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TestSampleEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TestSampleEntry& from) {
    TestSampleEntry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestSampleEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "classifierpb.TestSampleEntry";
  }
  protected:
  explicit TestSampleEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFeaturesFieldNumber = 2,
    kGroundTruthFieldNumber = 3,
    kSampleIdFieldNumber = 1,
  };
  // repeated float features = 2;
  int features_size() const;
  private:
  int _internal_features_size() const;
  public:
  void clear_features();
  private:
  float _internal_features(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_features() const;
  void _internal_add_features(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_features();
  public:
  float features(int index) const;
  void set_features(int index, float value);
  void add_features(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      features() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_features();

  // .classifierpb.Target ground_truth = 3;
  bool has_ground_truth() const;
  private:
  bool _internal_has_ground_truth() const;
  public:
  void clear_ground_truth();
  const ::classifierpb::Target& ground_truth() const;
  PROTOBUF_NODISCARD ::classifierpb::Target* release_ground_truth();
  ::classifierpb::Target* mutable_ground_truth();
  void set_allocated_ground_truth(::classifierpb::Target* ground_truth);
  private:
  const ::classifierpb::Target& _internal_ground_truth() const;
  ::classifierpb::Target* _internal_mutable_ground_truth();
  public:
  void unsafe_arena_set_allocated_ground_truth(
      ::classifierpb::Target* ground_truth);
  ::classifierpb::Target* unsafe_arena_release_ground_truth();

  // int32 sample_id = 1;
  void clear_sample_id();
  int32_t sample_id() const;
  void set_sample_id(int32_t value);
  private:
  int32_t _internal_sample_id() const;
  void _internal_set_sample_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:classifierpb.TestSampleEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > features_;
    ::classifierpb::Target* ground_truth_;
    int32_t sample_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_classifier_2eproto;
};
// -------------------------------------------------------------------

class TestSamples final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:classifierpb.TestSamples) */ {
 public:
  inline TestSamples() : TestSamples(nullptr) {}
  ~TestSamples() override;
  explicit PROTOBUF_CONSTEXPR TestSamples(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestSamples(const TestSamples& from);
  TestSamples(TestSamples&& from) noexcept
    : TestSamples() {
    *this = ::std::move(from);
  }

  inline TestSamples& operator=(const TestSamples& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestSamples& operator=(TestSamples&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestSamples& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestSamples* internal_default_instance() {
    return reinterpret_cast<const TestSamples*>(
               &_TestSamples_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TestSamples& a, TestSamples& b) {
    a.Swap(&b);
  }
  inline void Swap(TestSamples* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestSamples* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestSamples* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestSamples>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TestSamples& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TestSamples& from) {
    TestSamples::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestSamples* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "classifierpb.TestSamples";
  }
  protected:
  explicit TestSamples(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 1,
  };
  // repeated .classifierpb.TestSampleEntry entries = 1;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::classifierpb::TestSampleEntry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::classifierpb::TestSampleEntry >*
      mutable_entries();
  private:
  const ::classifierpb::TestSampleEntry& _internal_entries(int index) const;
  ::classifierpb::TestSampleEntry* _internal_add_entries();
  public:
  const ::classifierpb::TestSampleEntry& entries(int index) const;
  ::classifierpb::TestSampleEntry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::classifierpb::TestSampleEntry >&
      entries() const;

  // @@protoc_insertion_point(class_scope:classifierpb.TestSamples)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::classifierpb::TestSampleEntry > entries_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_classifier_2eproto;
};
// -------------------------------------------------------------------

class PredictedSampleEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:classifierpb.PredictedSampleEntry) */ {
 public:
  inline PredictedSampleEntry() : PredictedSampleEntry(nullptr) {}
  ~PredictedSampleEntry() override;
  explicit PROTOBUF_CONSTEXPR PredictedSampleEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PredictedSampleEntry(const PredictedSampleEntry& from);
  PredictedSampleEntry(PredictedSampleEntry&& from) noexcept
    : PredictedSampleEntry() {
    *this = ::std::move(from);
  }

  inline PredictedSampleEntry& operator=(const PredictedSampleEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline PredictedSampleEntry& operator=(PredictedSampleEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PredictedSampleEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const PredictedSampleEntry* internal_default_instance() {
    return reinterpret_cast<const PredictedSampleEntry*>(
               &_PredictedSampleEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PredictedSampleEntry& a, PredictedSampleEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(PredictedSampleEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PredictedSampleEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PredictedSampleEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PredictedSampleEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PredictedSampleEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PredictedSampleEntry& from) {
    PredictedSampleEntry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PredictedSampleEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "classifierpb.PredictedSampleEntry";
  }
  protected:
  explicit PredictedSampleEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFeaturesFieldNumber = 2,
    kTargetFieldNumber = 3,
    kSampleIdFieldNumber = 1,
  };
  // repeated float features = 2;
  int features_size() const;
  private:
  int _internal_features_size() const;
  public:
  void clear_features();
  private:
  float _internal_features(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_features() const;
  void _internal_add_features(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_features();
  public:
  float features(int index) const;
  void set_features(int index, float value);
  void add_features(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      features() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_features();

  // .classifierpb.Target target = 3;
  bool has_target() const;
  private:
  bool _internal_has_target() const;
  public:
  void clear_target();
  const ::classifierpb::Target& target() const;
  PROTOBUF_NODISCARD ::classifierpb::Target* release_target();
  ::classifierpb::Target* mutable_target();
  void set_allocated_target(::classifierpb::Target* target);
  private:
  const ::classifierpb::Target& _internal_target() const;
  ::classifierpb::Target* _internal_mutable_target();
  public:
  void unsafe_arena_set_allocated_target(
      ::classifierpb::Target* target);
  ::classifierpb::Target* unsafe_arena_release_target();

  // int32 sample_id = 1;
  void clear_sample_id();
  int32_t sample_id() const;
  void set_sample_id(int32_t value);
  private:
  int32_t _internal_sample_id() const;
  void _internal_set_sample_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:classifierpb.PredictedSampleEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > features_;
    ::classifierpb::Target* target_;
    int32_t sample_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_classifier_2eproto;
};
// -------------------------------------------------------------------

class PredictedSamples final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:classifierpb.PredictedSamples) */ {
 public:
  inline PredictedSamples() : PredictedSamples(nullptr) {}
  ~PredictedSamples() override;
  explicit PROTOBUF_CONSTEXPR PredictedSamples(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PredictedSamples(const PredictedSamples& from);
  PredictedSamples(PredictedSamples&& from) noexcept
    : PredictedSamples() {
    *this = ::std::move(from);
  }

  inline PredictedSamples& operator=(const PredictedSamples& from) {
    CopyFrom(from);
    return *this;
  }
  inline PredictedSamples& operator=(PredictedSamples&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PredictedSamples& default_instance() {
    return *internal_default_instance();
  }
  static inline const PredictedSamples* internal_default_instance() {
    return reinterpret_cast<const PredictedSamples*>(
               &_PredictedSamples_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(PredictedSamples& a, PredictedSamples& b) {
    a.Swap(&b);
  }
  inline void Swap(PredictedSamples* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PredictedSamples* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PredictedSamples* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PredictedSamples>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PredictedSamples& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PredictedSamples& from) {
    PredictedSamples::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PredictedSamples* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "classifierpb.PredictedSamples";
  }
  protected:
  explicit PredictedSamples(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 1,
  };
  // repeated .classifierpb.PredictedSampleEntry entries = 1;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::classifierpb::PredictedSampleEntry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::classifierpb::PredictedSampleEntry >*
      mutable_entries();
  private:
  const ::classifierpb::PredictedSampleEntry& _internal_entries(int index) const;
  ::classifierpb::PredictedSampleEntry* _internal_add_entries();
  public:
  const ::classifierpb::PredictedSampleEntry& entries(int index) const;
  ::classifierpb::PredictedSampleEntry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::classifierpb::PredictedSampleEntry >&
      entries() const;

  // @@protoc_insertion_point(class_scope:classifierpb.PredictedSamples)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::classifierpb::PredictedSampleEntry > entries_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_classifier_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Target

// int32 target_int = 1;
inline bool Target::_internal_has_target_int() const {
  return target_case() == kTargetInt;
}
inline bool Target::has_target_int() const {
  return _internal_has_target_int();
}
inline void Target::set_has_target_int() {
  _impl_._oneof_case_[0] = kTargetInt;
}
inline void Target::clear_target_int() {
  if (_internal_has_target_int()) {
    _impl_.target_.target_int_ = 0;
    clear_has_target();
  }
}
inline int32_t Target::_internal_target_int() const {
  if (_internal_has_target_int()) {
    return _impl_.target_.target_int_;
  }
  return 0;
}
inline void Target::_internal_set_target_int(int32_t value) {
  if (!_internal_has_target_int()) {
    clear_target();
    set_has_target_int();
  }
  _impl_.target_.target_int_ = value;
}
inline int32_t Target::target_int() const {
  // @@protoc_insertion_point(field_get:classifierpb.Target.target_int)
  return _internal_target_int();
}
inline void Target::set_target_int(int32_t value) {
  _internal_set_target_int(value);
  // @@protoc_insertion_point(field_set:classifierpb.Target.target_int)
}

// string target_str = 2;
inline bool Target::_internal_has_target_str() const {
  return target_case() == kTargetStr;
}
inline bool Target::has_target_str() const {
  return _internal_has_target_str();
}
inline void Target::set_has_target_str() {
  _impl_._oneof_case_[0] = kTargetStr;
}
inline void Target::clear_target_str() {
  if (_internal_has_target_str()) {
    _impl_.target_.target_str_.Destroy();
    clear_has_target();
  }
}
inline const std::string& Target::target_str() const {
  // @@protoc_insertion_point(field_get:classifierpb.Target.target_str)
  return _internal_target_str();
}
template <typename ArgT0, typename... ArgT>
inline void Target::set_target_str(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_target_str()) {
    clear_target();
    set_has_target_str();
    _impl_.target_.target_str_.InitDefault();
  }
  _impl_.target_.target_str_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:classifierpb.Target.target_str)
}
inline std::string* Target::mutable_target_str() {
  std::string* _s = _internal_mutable_target_str();
  // @@protoc_insertion_point(field_mutable:classifierpb.Target.target_str)
  return _s;
}
inline const std::string& Target::_internal_target_str() const {
  if (_internal_has_target_str()) {
    return _impl_.target_.target_str_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Target::_internal_set_target_str(const std::string& value) {
  if (!_internal_has_target_str()) {
    clear_target();
    set_has_target_str();
    _impl_.target_.target_str_.InitDefault();
  }
  _impl_.target_.target_str_.Set(value, GetArenaForAllocation());
}
inline std::string* Target::_internal_mutable_target_str() {
  if (!_internal_has_target_str()) {
    clear_target();
    set_has_target_str();
    _impl_.target_.target_str_.InitDefault();
  }
  return _impl_.target_.target_str_.Mutable(      GetArenaForAllocation());
}
inline std::string* Target::release_target_str() {
  // @@protoc_insertion_point(field_release:classifierpb.Target.target_str)
  if (_internal_has_target_str()) {
    clear_has_target();
    return _impl_.target_.target_str_.Release();
  } else {
    return nullptr;
  }
}
inline void Target::set_allocated_target_str(std::string* target_str) {
  if (has_target()) {
    clear_target();
  }
  if (target_str != nullptr) {
    set_has_target_str();
    _impl_.target_.target_str_.InitAllocated(target_str, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:classifierpb.Target.target_str)
}

inline bool Target::has_target() const {
  return target_case() != TARGET_NOT_SET;
}
inline void Target::clear_has_target() {
  _impl_._oneof_case_[0] = TARGET_NOT_SET;
}
inline Target::TargetCase Target::target_case() const {
  return Target::TargetCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// DatasetEntry

// repeated float features = 1;
inline int DatasetEntry::_internal_features_size() const {
  return _impl_.features_.size();
}
inline int DatasetEntry::features_size() const {
  return _internal_features_size();
}
inline void DatasetEntry::clear_features() {
  _impl_.features_.Clear();
}
inline float DatasetEntry::_internal_features(int index) const {
  return _impl_.features_.Get(index);
}
inline float DatasetEntry::features(int index) const {
  // @@protoc_insertion_point(field_get:classifierpb.DatasetEntry.features)
  return _internal_features(index);
}
inline void DatasetEntry::set_features(int index, float value) {
  _impl_.features_.Set(index, value);
  // @@protoc_insertion_point(field_set:classifierpb.DatasetEntry.features)
}
inline void DatasetEntry::_internal_add_features(float value) {
  _impl_.features_.Add(value);
}
inline void DatasetEntry::add_features(float value) {
  _internal_add_features(value);
  // @@protoc_insertion_point(field_add:classifierpb.DatasetEntry.features)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
DatasetEntry::_internal_features() const {
  return _impl_.features_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
DatasetEntry::features() const {
  // @@protoc_insertion_point(field_list:classifierpb.DatasetEntry.features)
  return _internal_features();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
DatasetEntry::_internal_mutable_features() {
  return &_impl_.features_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
DatasetEntry::mutable_features() {
  // @@protoc_insertion_point(field_mutable_list:classifierpb.DatasetEntry.features)
  return _internal_mutable_features();
}

// .classifierpb.Target target = 2;
inline bool DatasetEntry::_internal_has_target() const {
  return this != internal_default_instance() && _impl_.target_ != nullptr;
}
inline bool DatasetEntry::has_target() const {
  return _internal_has_target();
}
inline void DatasetEntry::clear_target() {
  if (GetArenaForAllocation() == nullptr && _impl_.target_ != nullptr) {
    delete _impl_.target_;
  }
  _impl_.target_ = nullptr;
}
inline const ::classifierpb::Target& DatasetEntry::_internal_target() const {
  const ::classifierpb::Target* p = _impl_.target_;
  return p != nullptr ? *p : reinterpret_cast<const ::classifierpb::Target&>(
      ::classifierpb::_Target_default_instance_);
}
inline const ::classifierpb::Target& DatasetEntry::target() const {
  // @@protoc_insertion_point(field_get:classifierpb.DatasetEntry.target)
  return _internal_target();
}
inline void DatasetEntry::unsafe_arena_set_allocated_target(
    ::classifierpb::Target* target) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_);
  }
  _impl_.target_ = target;
  if (target) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:classifierpb.DatasetEntry.target)
}
inline ::classifierpb::Target* DatasetEntry::release_target() {
  
  ::classifierpb::Target* temp = _impl_.target_;
  _impl_.target_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::classifierpb::Target* DatasetEntry::unsafe_arena_release_target() {
  // @@protoc_insertion_point(field_release:classifierpb.DatasetEntry.target)
  
  ::classifierpb::Target* temp = _impl_.target_;
  _impl_.target_ = nullptr;
  return temp;
}
inline ::classifierpb::Target* DatasetEntry::_internal_mutable_target() {
  
  if (_impl_.target_ == nullptr) {
    auto* p = CreateMaybeMessage<::classifierpb::Target>(GetArenaForAllocation());
    _impl_.target_ = p;
  }
  return _impl_.target_;
}
inline ::classifierpb::Target* DatasetEntry::mutable_target() {
  ::classifierpb::Target* _msg = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:classifierpb.DatasetEntry.target)
  return _msg;
}
inline void DatasetEntry::set_allocated_target(::classifierpb::Target* target) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.target_;
  }
  if (target) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(target);
    if (message_arena != submessage_arena) {
      target = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.target_ = target;
  // @@protoc_insertion_point(field_set_allocated:classifierpb.DatasetEntry.target)
}

// -------------------------------------------------------------------

// Dataset

// repeated .classifierpb.DatasetEntry entries = 1;
inline int Dataset::_internal_entries_size() const {
  return _impl_.entries_.size();
}
inline int Dataset::entries_size() const {
  return _internal_entries_size();
}
inline void Dataset::clear_entries() {
  _impl_.entries_.Clear();
}
inline ::classifierpb::DatasetEntry* Dataset::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:classifierpb.Dataset.entries)
  return _impl_.entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::classifierpb::DatasetEntry >*
Dataset::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:classifierpb.Dataset.entries)
  return &_impl_.entries_;
}
inline const ::classifierpb::DatasetEntry& Dataset::_internal_entries(int index) const {
  return _impl_.entries_.Get(index);
}
inline const ::classifierpb::DatasetEntry& Dataset::entries(int index) const {
  // @@protoc_insertion_point(field_get:classifierpb.Dataset.entries)
  return _internal_entries(index);
}
inline ::classifierpb::DatasetEntry* Dataset::_internal_add_entries() {
  return _impl_.entries_.Add();
}
inline ::classifierpb::DatasetEntry* Dataset::add_entries() {
  ::classifierpb::DatasetEntry* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:classifierpb.Dataset.entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::classifierpb::DatasetEntry >&
Dataset::entries() const {
  // @@protoc_insertion_point(field_list:classifierpb.Dataset.entries)
  return _impl_.entries_;
}

// -------------------------------------------------------------------

// SupportSampleEntry

// int32 sample_id = 1;
inline void SupportSampleEntry::clear_sample_id() {
  _impl_.sample_id_ = 0;
}
inline int32_t SupportSampleEntry::_internal_sample_id() const {
  return _impl_.sample_id_;
}
inline int32_t SupportSampleEntry::sample_id() const {
  // @@protoc_insertion_point(field_get:classifierpb.SupportSampleEntry.sample_id)
  return _internal_sample_id();
}
inline void SupportSampleEntry::_internal_set_sample_id(int32_t value) {
  
  _impl_.sample_id_ = value;
}
inline void SupportSampleEntry::set_sample_id(int32_t value) {
  _internal_set_sample_id(value);
  // @@protoc_insertion_point(field_set:classifierpb.SupportSampleEntry.sample_id)
}

// repeated float features = 2;
inline int SupportSampleEntry::_internal_features_size() const {
  return _impl_.features_.size();
}
inline int SupportSampleEntry::features_size() const {
  return _internal_features_size();
}
inline void SupportSampleEntry::clear_features() {
  _impl_.features_.Clear();
}
inline float SupportSampleEntry::_internal_features(int index) const {
  return _impl_.features_.Get(index);
}
inline float SupportSampleEntry::features(int index) const {
  // @@protoc_insertion_point(field_get:classifierpb.SupportSampleEntry.features)
  return _internal_features(index);
}
inline void SupportSampleEntry::set_features(int index, float value) {
  _impl_.features_.Set(index, value);
  // @@protoc_insertion_point(field_set:classifierpb.SupportSampleEntry.features)
}
inline void SupportSampleEntry::_internal_add_features(float value) {
  _impl_.features_.Add(value);
}
inline void SupportSampleEntry::add_features(float value) {
  _internal_add_features(value);
  // @@protoc_insertion_point(field_add:classifierpb.SupportSampleEntry.features)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
SupportSampleEntry::_internal_features() const {
  return _impl_.features_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
SupportSampleEntry::features() const {
  // @@protoc_insertion_point(field_list:classifierpb.SupportSampleEntry.features)
  return _internal_features();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
SupportSampleEntry::_internal_mutable_features() {
  return &_impl_.features_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
SupportSampleEntry::mutable_features() {
  // @@protoc_insertion_point(field_mutable_list:classifierpb.SupportSampleEntry.features)
  return _internal_mutable_features();
}

// .classifierpb.Target target = 3;
inline bool SupportSampleEntry::_internal_has_target() const {
  return this != internal_default_instance() && _impl_.target_ != nullptr;
}
inline bool SupportSampleEntry::has_target() const {
  return _internal_has_target();
}
inline void SupportSampleEntry::clear_target() {
  if (GetArenaForAllocation() == nullptr && _impl_.target_ != nullptr) {
    delete _impl_.target_;
  }
  _impl_.target_ = nullptr;
}
inline const ::classifierpb::Target& SupportSampleEntry::_internal_target() const {
  const ::classifierpb::Target* p = _impl_.target_;
  return p != nullptr ? *p : reinterpret_cast<const ::classifierpb::Target&>(
      ::classifierpb::_Target_default_instance_);
}
inline const ::classifierpb::Target& SupportSampleEntry::target() const {
  // @@protoc_insertion_point(field_get:classifierpb.SupportSampleEntry.target)
  return _internal_target();
}
inline void SupportSampleEntry::unsafe_arena_set_allocated_target(
    ::classifierpb::Target* target) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_);
  }
  _impl_.target_ = target;
  if (target) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:classifierpb.SupportSampleEntry.target)
}
inline ::classifierpb::Target* SupportSampleEntry::release_target() {
  
  ::classifierpb::Target* temp = _impl_.target_;
  _impl_.target_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::classifierpb::Target* SupportSampleEntry::unsafe_arena_release_target() {
  // @@protoc_insertion_point(field_release:classifierpb.SupportSampleEntry.target)
  
  ::classifierpb::Target* temp = _impl_.target_;
  _impl_.target_ = nullptr;
  return temp;
}
inline ::classifierpb::Target* SupportSampleEntry::_internal_mutable_target() {
  
  if (_impl_.target_ == nullptr) {
    auto* p = CreateMaybeMessage<::classifierpb::Target>(GetArenaForAllocation());
    _impl_.target_ = p;
  }
  return _impl_.target_;
}
inline ::classifierpb::Target* SupportSampleEntry::mutable_target() {
  ::classifierpb::Target* _msg = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:classifierpb.SupportSampleEntry.target)
  return _msg;
}
inline void SupportSampleEntry::set_allocated_target(::classifierpb::Target* target) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.target_;
  }
  if (target) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(target);
    if (message_arena != submessage_arena) {
      target = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.target_ = target;
  // @@protoc_insertion_point(field_set_allocated:classifierpb.SupportSampleEntry.target)
}

// -------------------------------------------------------------------

// SupportSamples

// repeated .classifierpb.SupportSampleEntry entries = 1;
inline int SupportSamples::_internal_entries_size() const {
  return _impl_.entries_.size();
}
inline int SupportSamples::entries_size() const {
  return _internal_entries_size();
}
inline void SupportSamples::clear_entries() {
  _impl_.entries_.Clear();
}
inline ::classifierpb::SupportSampleEntry* SupportSamples::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:classifierpb.SupportSamples.entries)
  return _impl_.entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::classifierpb::SupportSampleEntry >*
SupportSamples::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:classifierpb.SupportSamples.entries)
  return &_impl_.entries_;
}
inline const ::classifierpb::SupportSampleEntry& SupportSamples::_internal_entries(int index) const {
  return _impl_.entries_.Get(index);
}
inline const ::classifierpb::SupportSampleEntry& SupportSamples::entries(int index) const {
  // @@protoc_insertion_point(field_get:classifierpb.SupportSamples.entries)
  return _internal_entries(index);
}
inline ::classifierpb::SupportSampleEntry* SupportSamples::_internal_add_entries() {
  return _impl_.entries_.Add();
}
inline ::classifierpb::SupportSampleEntry* SupportSamples::add_entries() {
  ::classifierpb::SupportSampleEntry* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:classifierpb.SupportSamples.entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::classifierpb::SupportSampleEntry >&
SupportSamples::entries() const {
  // @@protoc_insertion_point(field_list:classifierpb.SupportSamples.entries)
  return _impl_.entries_;
}

// -------------------------------------------------------------------

// TestSampleEntry

// int32 sample_id = 1;
inline void TestSampleEntry::clear_sample_id() {
  _impl_.sample_id_ = 0;
}
inline int32_t TestSampleEntry::_internal_sample_id() const {
  return _impl_.sample_id_;
}
inline int32_t TestSampleEntry::sample_id() const {
  // @@protoc_insertion_point(field_get:classifierpb.TestSampleEntry.sample_id)
  return _internal_sample_id();
}
inline void TestSampleEntry::_internal_set_sample_id(int32_t value) {
  
  _impl_.sample_id_ = value;
}
inline void TestSampleEntry::set_sample_id(int32_t value) {
  _internal_set_sample_id(value);
  // @@protoc_insertion_point(field_set:classifierpb.TestSampleEntry.sample_id)
}

// repeated float features = 2;
inline int TestSampleEntry::_internal_features_size() const {
  return _impl_.features_.size();
}
inline int TestSampleEntry::features_size() const {
  return _internal_features_size();
}
inline void TestSampleEntry::clear_features() {
  _impl_.features_.Clear();
}
inline float TestSampleEntry::_internal_features(int index) const {
  return _impl_.features_.Get(index);
}
inline float TestSampleEntry::features(int index) const {
  // @@protoc_insertion_point(field_get:classifierpb.TestSampleEntry.features)
  return _internal_features(index);
}
inline void TestSampleEntry::set_features(int index, float value) {
  _impl_.features_.Set(index, value);
  // @@protoc_insertion_point(field_set:classifierpb.TestSampleEntry.features)
}
inline void TestSampleEntry::_internal_add_features(float value) {
  _impl_.features_.Add(value);
}
inline void TestSampleEntry::add_features(float value) {
  _internal_add_features(value);
  // @@protoc_insertion_point(field_add:classifierpb.TestSampleEntry.features)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
TestSampleEntry::_internal_features() const {
  return _impl_.features_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
TestSampleEntry::features() const {
  // @@protoc_insertion_point(field_list:classifierpb.TestSampleEntry.features)
  return _internal_features();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
TestSampleEntry::_internal_mutable_features() {
  return &_impl_.features_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
TestSampleEntry::mutable_features() {
  // @@protoc_insertion_point(field_mutable_list:classifierpb.TestSampleEntry.features)
  return _internal_mutable_features();
}

// .classifierpb.Target ground_truth = 3;
inline bool TestSampleEntry::_internal_has_ground_truth() const {
  return this != internal_default_instance() && _impl_.ground_truth_ != nullptr;
}
inline bool TestSampleEntry::has_ground_truth() const {
  return _internal_has_ground_truth();
}
inline void TestSampleEntry::clear_ground_truth() {
  if (GetArenaForAllocation() == nullptr && _impl_.ground_truth_ != nullptr) {
    delete _impl_.ground_truth_;
  }
  _impl_.ground_truth_ = nullptr;
}
inline const ::classifierpb::Target& TestSampleEntry::_internal_ground_truth() const {
  const ::classifierpb::Target* p = _impl_.ground_truth_;
  return p != nullptr ? *p : reinterpret_cast<const ::classifierpb::Target&>(
      ::classifierpb::_Target_default_instance_);
}
inline const ::classifierpb::Target& TestSampleEntry::ground_truth() const {
  // @@protoc_insertion_point(field_get:classifierpb.TestSampleEntry.ground_truth)
  return _internal_ground_truth();
}
inline void TestSampleEntry::unsafe_arena_set_allocated_ground_truth(
    ::classifierpb::Target* ground_truth) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ground_truth_);
  }
  _impl_.ground_truth_ = ground_truth;
  if (ground_truth) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:classifierpb.TestSampleEntry.ground_truth)
}
inline ::classifierpb::Target* TestSampleEntry::release_ground_truth() {
  
  ::classifierpb::Target* temp = _impl_.ground_truth_;
  _impl_.ground_truth_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::classifierpb::Target* TestSampleEntry::unsafe_arena_release_ground_truth() {
  // @@protoc_insertion_point(field_release:classifierpb.TestSampleEntry.ground_truth)
  
  ::classifierpb::Target* temp = _impl_.ground_truth_;
  _impl_.ground_truth_ = nullptr;
  return temp;
}
inline ::classifierpb::Target* TestSampleEntry::_internal_mutable_ground_truth() {
  
  if (_impl_.ground_truth_ == nullptr) {
    auto* p = CreateMaybeMessage<::classifierpb::Target>(GetArenaForAllocation());
    _impl_.ground_truth_ = p;
  }
  return _impl_.ground_truth_;
}
inline ::classifierpb::Target* TestSampleEntry::mutable_ground_truth() {
  ::classifierpb::Target* _msg = _internal_mutable_ground_truth();
  // @@protoc_insertion_point(field_mutable:classifierpb.TestSampleEntry.ground_truth)
  return _msg;
}
inline void TestSampleEntry::set_allocated_ground_truth(::classifierpb::Target* ground_truth) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ground_truth_;
  }
  if (ground_truth) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ground_truth);
    if (message_arena != submessage_arena) {
      ground_truth = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ground_truth, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ground_truth_ = ground_truth;
  // @@protoc_insertion_point(field_set_allocated:classifierpb.TestSampleEntry.ground_truth)
}

// -------------------------------------------------------------------

// TestSamples

// repeated .classifierpb.TestSampleEntry entries = 1;
inline int TestSamples::_internal_entries_size() const {
  return _impl_.entries_.size();
}
inline int TestSamples::entries_size() const {
  return _internal_entries_size();
}
inline void TestSamples::clear_entries() {
  _impl_.entries_.Clear();
}
inline ::classifierpb::TestSampleEntry* TestSamples::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:classifierpb.TestSamples.entries)
  return _impl_.entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::classifierpb::TestSampleEntry >*
TestSamples::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:classifierpb.TestSamples.entries)
  return &_impl_.entries_;
}
inline const ::classifierpb::TestSampleEntry& TestSamples::_internal_entries(int index) const {
  return _impl_.entries_.Get(index);
}
inline const ::classifierpb::TestSampleEntry& TestSamples::entries(int index) const {
  // @@protoc_insertion_point(field_get:classifierpb.TestSamples.entries)
  return _internal_entries(index);
}
inline ::classifierpb::TestSampleEntry* TestSamples::_internal_add_entries() {
  return _impl_.entries_.Add();
}
inline ::classifierpb::TestSampleEntry* TestSamples::add_entries() {
  ::classifierpb::TestSampleEntry* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:classifierpb.TestSamples.entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::classifierpb::TestSampleEntry >&
TestSamples::entries() const {
  // @@protoc_insertion_point(field_list:classifierpb.TestSamples.entries)
  return _impl_.entries_;
}

// -------------------------------------------------------------------

// PredictedSampleEntry

// int32 sample_id = 1;
inline void PredictedSampleEntry::clear_sample_id() {
  _impl_.sample_id_ = 0;
}
inline int32_t PredictedSampleEntry::_internal_sample_id() const {
  return _impl_.sample_id_;
}
inline int32_t PredictedSampleEntry::sample_id() const {
  // @@protoc_insertion_point(field_get:classifierpb.PredictedSampleEntry.sample_id)
  return _internal_sample_id();
}
inline void PredictedSampleEntry::_internal_set_sample_id(int32_t value) {
  
  _impl_.sample_id_ = value;
}
inline void PredictedSampleEntry::set_sample_id(int32_t value) {
  _internal_set_sample_id(value);
  // @@protoc_insertion_point(field_set:classifierpb.PredictedSampleEntry.sample_id)
}

// repeated float features = 2;
inline int PredictedSampleEntry::_internal_features_size() const {
  return _impl_.features_.size();
}
inline int PredictedSampleEntry::features_size() const {
  return _internal_features_size();
}
inline void PredictedSampleEntry::clear_features() {
  _impl_.features_.Clear();
}
inline float PredictedSampleEntry::_internal_features(int index) const {
  return _impl_.features_.Get(index);
}
inline float PredictedSampleEntry::features(int index) const {
  // @@protoc_insertion_point(field_get:classifierpb.PredictedSampleEntry.features)
  return _internal_features(index);
}
inline void PredictedSampleEntry::set_features(int index, float value) {
  _impl_.features_.Set(index, value);
  // @@protoc_insertion_point(field_set:classifierpb.PredictedSampleEntry.features)
}
inline void PredictedSampleEntry::_internal_add_features(float value) {
  _impl_.features_.Add(value);
}
inline void PredictedSampleEntry::add_features(float value) {
  _internal_add_features(value);
  // @@protoc_insertion_point(field_add:classifierpb.PredictedSampleEntry.features)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
PredictedSampleEntry::_internal_features() const {
  return _impl_.features_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
PredictedSampleEntry::features() const {
  // @@protoc_insertion_point(field_list:classifierpb.PredictedSampleEntry.features)
  return _internal_features();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
PredictedSampleEntry::_internal_mutable_features() {
  return &_impl_.features_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
PredictedSampleEntry::mutable_features() {
  // @@protoc_insertion_point(field_mutable_list:classifierpb.PredictedSampleEntry.features)
  return _internal_mutable_features();
}

// .classifierpb.Target target = 3;
inline bool PredictedSampleEntry::_internal_has_target() const {
  return this != internal_default_instance() && _impl_.target_ != nullptr;
}
inline bool PredictedSampleEntry::has_target() const {
  return _internal_has_target();
}
inline void PredictedSampleEntry::clear_target() {
  if (GetArenaForAllocation() == nullptr && _impl_.target_ != nullptr) {
    delete _impl_.target_;
  }
  _impl_.target_ = nullptr;
}
inline const ::classifierpb::Target& PredictedSampleEntry::_internal_target() const {
  const ::classifierpb::Target* p = _impl_.target_;
  return p != nullptr ? *p : reinterpret_cast<const ::classifierpb::Target&>(
      ::classifierpb::_Target_default_instance_);
}
inline const ::classifierpb::Target& PredictedSampleEntry::target() const {
  // @@protoc_insertion_point(field_get:classifierpb.PredictedSampleEntry.target)
  return _internal_target();
}
inline void PredictedSampleEntry::unsafe_arena_set_allocated_target(
    ::classifierpb::Target* target) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_);
  }
  _impl_.target_ = target;
  if (target) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:classifierpb.PredictedSampleEntry.target)
}
inline ::classifierpb::Target* PredictedSampleEntry::release_target() {
  
  ::classifierpb::Target* temp = _impl_.target_;
  _impl_.target_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::classifierpb::Target* PredictedSampleEntry::unsafe_arena_release_target() {
  // @@protoc_insertion_point(field_release:classifierpb.PredictedSampleEntry.target)
  
  ::classifierpb::Target* temp = _impl_.target_;
  _impl_.target_ = nullptr;
  return temp;
}
inline ::classifierpb::Target* PredictedSampleEntry::_internal_mutable_target() {
  
  if (_impl_.target_ == nullptr) {
    auto* p = CreateMaybeMessage<::classifierpb::Target>(GetArenaForAllocation());
    _impl_.target_ = p;
  }
  return _impl_.target_;
}
inline ::classifierpb::Target* PredictedSampleEntry::mutable_target() {
  ::classifierpb::Target* _msg = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:classifierpb.PredictedSampleEntry.target)
  return _msg;
}
inline void PredictedSampleEntry::set_allocated_target(::classifierpb::Target* target) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.target_;
  }
  if (target) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(target);
    if (message_arena != submessage_arena) {
      target = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.target_ = target;
  // @@protoc_insertion_point(field_set_allocated:classifierpb.PredictedSampleEntry.target)
}

// -------------------------------------------------------------------

// PredictedSamples

// repeated .classifierpb.PredictedSampleEntry entries = 1;
inline int PredictedSamples::_internal_entries_size() const {
  return _impl_.entries_.size();
}
inline int PredictedSamples::entries_size() const {
  return _internal_entries_size();
}
inline void PredictedSamples::clear_entries() {
  _impl_.entries_.Clear();
}
inline ::classifierpb::PredictedSampleEntry* PredictedSamples::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:classifierpb.PredictedSamples.entries)
  return _impl_.entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::classifierpb::PredictedSampleEntry >*
PredictedSamples::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:classifierpb.PredictedSamples.entries)
  return &_impl_.entries_;
}
inline const ::classifierpb::PredictedSampleEntry& PredictedSamples::_internal_entries(int index) const {
  return _impl_.entries_.Get(index);
}
inline const ::classifierpb::PredictedSampleEntry& PredictedSamples::entries(int index) const {
  // @@protoc_insertion_point(field_get:classifierpb.PredictedSamples.entries)
  return _internal_entries(index);
}
inline ::classifierpb::PredictedSampleEntry* PredictedSamples::_internal_add_entries() {
  return _impl_.entries_.Add();
}
inline ::classifierpb::PredictedSampleEntry* PredictedSamples::add_entries() {
  ::classifierpb::PredictedSampleEntry* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:classifierpb.PredictedSamples.entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::classifierpb::PredictedSampleEntry >&
PredictedSamples::entries() const {
  // @@protoc_insertion_point(field_list:classifierpb.PredictedSamples.entries)
  return _impl_.entries_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace classifierpb

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_classifier_2eproto
